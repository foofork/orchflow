#!/bin/bash

# Define ANSI color codes
NC='\033[0m'       # No Color - Resets all attributes
BOLD='\033[1m'     # Bold
RED='\033[31m'     # Red text
GREEN='\033[32m'   # Green text
YELLOW='\033[33m'  # Yellow text
CYAN='\033[36m'    # Cyan text

# This script sets up the 'commit-msg' Git hook in the current repository.
# It offers configurable options for stripping AI authorship patterns and other content.
#
# Usage:
# 1. Save this script as 'setup_commit_hook.sh' (or any other name) in the root of your Git repository.
# 2. Make it executable: chmod +x setup_commit_hook.sh
# 3. Run it: ./setup_commit_hook.sh
#
# This script is designed to be run manually per repository.

# Function to get the root directory of the current Git repository
get_git_root_dir() {
    git rev-parse --show-toplevel 2>/dev/null
}

# Function to generate the content of the commit-msg hook based on options
generate_hook_content() {
    local choice="$1"
    local custom_patterns="$2" # Comma-separated string

    # --- Special Case: Install Default Git Hook (Choice 3) ---
    if [ "$choice" == "3" ]; then
        cat <<'EOF_DEFAULT_HOOK_CONTENT'
#!/bin/bash
#
# This is the default 'commit-msg' Git hook, installed by setup_commit_hook.sh.
# It does not include any AI cleaning logic.
#
# Called by "git commit" with one argument, the name of the file
# that has the commit message. The hook is allowed to edit the message file.

COMMIT_MSG_FILE="$1"

# --- Original Git Sample Hook Content (Unmodified) ---

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1>/p')
# grep -qs "^$SOB" "$COMMIT_MSG_FILE" || echo "$SOB" >> "$COMMIT_MSG_FILE"

# This example catches duplicate Signed-off-by lines.
test "" = "$(grep '^Signed-off-by: ' "$COMMIT_MSG_FILE" | \
            sort | uniq -c | sed -E '/^[[:space:]]*1[[:space:]]/d')" || {
        echo >&2 "Duplicate Signed-off-by lines."
        exit 1
}

exit 0 # Exit with 0 to allow the commit to proceed
EOF_DEFAULT_HOOK_CONTENT
        return # Exit the function early as content is fully generated
    fi

    # --- For other choices (1 & 2), continue with cleaning logic ---

    # Temporary file to store individual sed arguments (-e 'script')
    # This file will contain one -e '...' argument per line.
    local SED_ARGS_FILE=$(mktemp)

    # Ensure cleanup on exit
    trap "rm -f \"$SED_ARGS_FILE\"" EXIT

    # Core Cleaning Logic - write -e arguments directly to SED_ARGS_FILE
    if [ "$choice" == "1" ]; then # Aggressive AI Cleanup
        cat <<'EOF_AGGRESSIVE_SEDS' >> "$SED_ARGS_FILE"
-e "/^Co-authored-by: (Claude Code|GitHub Copilot|ChatGPT|Copilot|Bard|Gemini|Aider|Cursor|Code Llama|CodeWhisperer|Kite|Tabnine|Fauxpilot|Cody|Jedi|Pylint|Black|Ruff|Mypy|ESLint|Prettier|Deno Lint|SwiftLint|rubocop|ShellCheck|Hadolint|Semgrep|DeepCode|Snyk Code|SonarQube|Veracode|Checkmarx|PMD|FindBugs|SpotBugs|ErrorProne|Flake8|isort|Autopep8|Yapf|GolangCI-Lint|Clippy|rustfmt|clippy) <.*@.*>$/d"
-e "/^Co-authored-by: (AI|LLM) (Assistant|Bot|Model) <.*@.*>$/d"
-e "/^Co-authored-by: AI (Assistant|Bot|Model)$/d"
-e "/^Co-authored-by: Generated by AI$/d"
-e "/^Generated by (AI|LLM|ChatGPT|Copilot|Bard|Claude|Gemini|GitHub Copilot|Code Llama|CodeWhisperer|Kite|Tabnine|Fauxpilot|Cody|Cursor|Jedi|Pylint|Black|Ruff|Mypy|ESLint|Prettier|Deno Lint|SwiftLint|rubocop|ShellCheck|Hadolint|Semgrep|DeepCode|Snyk Code|SonarQube|Veracode|Checkmarx|PMD|FindBugs|SpotBugs|ErrorProne|Flake8|isort|Autopep8|Yapf|GolangCI-Lint|Clippy|rustfmt|clippy).*$/d"
-e "/^Authored by (AI|LLM|Code Llama).*$/d"
-e "/^AI-generated (content|text|code|message)(.*)?$/d"
-e "/^AI (assisted|contributed|powered) (commit|message|code)?(.*)?$/d"
-e "/^Powered by (AI|LLM).*$/d"
-e "/^This commit was (partially |largely |entirely )?generated by (AI|LLM)(:?.*)?$/d"
-e "s/\\b(AI-generated|AI assisted|LLM generated|AI generated)\\b//g"
-e "s/\\b(generated by AI|authored by AI|powered by AI)\\b//g"
-e "s/\\b(via AI|via LLM|using AI|using LLM)\\b//g"
-e "s/\\b(by AI|by LLM)\\b//g"
-e "s/\\b(Claude|ChatGPT|Copilot|Bard|Gemini|Aider|Cursor) (contribution|assisted|authored)\\b//g"
-e "s/\\b(AI contribution|LLM contribution)\\b//g"
EOF_AGGRESSIVE_SEDS
    elif [ "$choice" == "2" ]; then # Remove ALL Co-authored-by lines
        cat <<'EOF_ALL_COAUTHORED_SEDS' >> "$SED_ARGS_FILE"
-e "/^Co-authored-by: /d"
EOF_ALL_COAUTHORED_SEDS
    fi

    # Add custom patterns if provided (applies on top of chosen mode)
    if [ -n "$custom_patterns" ]; then
        IFS=',' read -ra ADDR <<< "$custom_patterns"
        for pattern in "${ADDR[@]}"; do
            pattern_trimmed=$(echo "$pattern" | xargs) # Trim whitespace
            if [ -n "$pattern_trimmed" ]; then
                # Escape forward slashes and double quotes in patterns for sed
                pattern_escaped=$(echo "$pattern_trimmed" | sed 's/[\/"]/\\&/g')
                echo "-e \"/$pattern_escaped/d\"" >> "$SED_ARGS_FILE" # Delete lines containing custom pattern
                echo "-e \"s/\\b$pattern_escaped\\b//g\"" >> "$SED_ARGS_FILE" # Replace custom pattern as a word
            fi
        done
    fi

    # Final cleanup commands (always apply)
    cat <<'EOF_CLEANUP_SEDS' >> "$SED_ARGS_FILE"
-e "s/[[:space:]]*$//g" # Remove trailing whitespace globally on the line
-e "s/[[:space:]]\+/ /g" # Replace multiple spaces with single space
-e "/^\s*$/d" # Remove blank lines that might result from stripping
EOF_CLEANUP_SEDS

    # Read all collected -e arguments and join them with spaces for the final sed command
    # Use 'tr' to replace newlines with spaces.
    local SED_OPTIONS=$(cat "$SED_ARGS_FILE" | tr '\n' ' ')

    # Construct the full hook script content
    cat <<EOF_HOOK_CONTENT
#!/bin/bash
#
# This Git commit-msg hook automatically cleans commit messages based on configuration.
# It is designed to strip out common AI authorship declarations and/or custom patterns.
#
# This script is automatically placed and managed by 'setup_commit_hook.sh'.
#
# Called by "git commit" with one argument, the name of the file
# that has the commit message. The hook is allowed to edit the message file.

COMMIT_MSG_FILE="\$1"

# --- Commit Message Cleaning ---
# The sed command uses:
# -i '' : Edits the file in-place. The '' is crucial for macOS compatibility.
# -E    : Uses extended regular expressions (ERE) for clearer syntax.
#
# The following patterns are applied based on your setup choices:
sed -i '' -E $SED_OPTIONS "\$COMMIT_MSG_FILE"

# --- End Commit Message Cleaning ---


# --- Original Git Sample Hook Content (Unmodified) ---

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=\$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1>/p')
# grep -qs "^\$SOB" "\$COMMIT_MSG_FILE" || echo "\$SOB" >> "\$COMMIT_MSG_FILE"

# This example catches duplicate Signed-off-by lines.
test "" = "\$(grep '^Signed-off-by: ' "\$COMMIT_MSG_FILE" | \\
            sort | uniq -c | sed -E '/^[[:space:]]*1[[:space:]]/d')" || {
        echo >&2 "Duplicate Signed-off-by lines."
        exit 1
}

exit 0 # Exit with 0 to allow the commit to proceed
EOF_HOOK_CONTENT
}

# --- Main Script Execution ---

GIT_ROOT_DIR=$(get_git_root_dir)

if [ -z "$GIT_ROOT_DIR" ]; then
    echo -e "${RED}${BOLD}Error: Not in a Git repository. Please run this script from within a Git project.${NC}"
    exit 1
fi

HOOKS_DIR="$GIT_ROOT_DIR/.git/hooks"
COMMIT_MSG_HOOK_PATH="$HOOKS_DIR/commit-msg"

echo -e "${CYAN}${BOLD}---------------------------------------------------------${NC}"
echo -e "${CYAN}${BOLD} Git Commit Message Cleaning Hook Setup${NC}"
echo -e "${CYAN}${BOLD} For repository: $GIT_ROOT_DIR${NC}"
echo -e "${CYAN}${BOLD}---------------------------------------------------------${NC}"
echo ""
echo "Please choose your preferred commit message cleaning mode:"
echo ""
echo "1. Aggressive AI Cleanup ${GREEN}(Recommended & Default)${NC}"
echo "   - Removes known AI authorship lines and phrases. Preserves human 'Co-authored-by:'."
echo ""
echo "2. Remove ALL 'Co-authored-by:' Lines ${YELLOW}(Use with Caution.)${NC}"
echo "   - Deletes ANY 'Co-authored-by:' line."
echo ""
echo "3. Install Default Git Commit Hook"
echo "   - Installs the standard Git 'commit-msg' hook (no AI cleaning)."
echo ""
echo "4. Exit ${BOLD}(Do Nothing)${NC}"
echo "   - The script will exit without installing or modifying any Git hooks."
echo ""

read -p "Enter your choice (1, 2, 3, or 4): " CHOICE

CUSTOM_PATTERNS="" # Initialize custom patterns to empty

case "$CHOICE" in
    1)
        echo -e "You chose: ${GREEN}Aggressive AI Cleanup.${NC}"
        read -p "Do you want to add custom patterns to strip? (y/N): " ADD_CUSTOM
        if [[ "$ADD_CUSTOM" =~ ^[Yy]$ ]]; then
            read -p "Enter custom patterns (comma-separated, e.g., 'MyInternalAI, AnotherBot'): " CUSTOM_PATTERNS
        fi
        ;;
    2)
        echo -e "You chose: ${YELLOW}Remove ALL 'Co-authored-by:' Lines.${NC}"
        echo ""
        echo -e "${RED}${BOLD}WARNING: This will remove ALL 'Co-authored-by:' lines, including human ones!${NC}"
        read -p "Are you absolutely sure you want to proceed with this? (y/N): " CONFIRM_ALL
        if ! [[ "$CONFIRM_ALL" =~ ^[Yy]$ ]]; then
            echo -e "${YELLOW}Operation cancelled. No hook installed.${NC}"
            exit 0
        fi
        read -p "Do you want to add custom patterns to strip? (y/N): " ADD_CUSTOM
        if [[ "$ADD_CUSTOM" =~ ^[Yy]$ ]]; then
            read -p "Enter custom patterns (comma-separated): " CUSTOM_PATTERNS
        fi
        ;;
    3)
        echo -e "You chose: ${GREEN}Install Default Git Commit Hook.${NC}"
        # No custom patterns or further prompts for this option, as it's a standard hook.
        ;;
    4)
        echo -e "${YELLOW}You chose: Exit. No Git hooks will be installed or modified.${NC}"
        exit 0 # Exit the script immediately without further action
        ;;
    *)
        echo -e "${RED}${BOLD}Invalid choice. Please enter 1, 2, 3, or 4.${NC}"
        exit 1
        ;;
esac

echo "--- Generating 'commit-msg' hook content ---"

# Generate the hook content and capture it
HOOK_CONTENT=$(generate_hook_content "$CHOICE" "$CUSTOM_PATTERNS")

echo "--- Writing hook to file ---"

# Create the hooks directory if it doesn't exist
mkdir -p "$HOOKS_DIR"

# Write the generated content to the hook file
echo "$HOOK_CONTENT" > "$COMMIT_MSG_HOOK_PATH"

# Make the hook executable
chmod +x "$COMMIT_MSG_HOOK_PATH"

echo -e "${GREEN}${BOLD}---------------------------------------------------------${NC}"
echo -e "${GREEN}${BOLD}Successfully installed/updated 'commit-msg' hook at: $COMMIT_MSG_HOOK_PATH${NC}"
echo -e "${GREEN}${BOLD}Your selected preferences have been applied.${NC}"
echo -e "${GREEN}${BOLD}Remember to test it with a sample commit!${NC}"
echo -e "${GREEN}${BOLD}---------------------------------------------------------${NC}"