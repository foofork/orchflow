name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to release'
        required: true
        default: 'v0.1.0'

env:
  RUST_VERSION: '1.75'
  NODE_VERSION: '18'

jobs:
  # Generate release changelog
  changelog:
    name: Generate Changelog
    runs-on: ubuntu-latest
    outputs:
      changelog: ${{ steps.changelog.outputs.changelog }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        run: |
          # Get the last tag
          LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          
          # Generate changelog
          if [ -z "$LAST_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --reverse)
          else
            CHANGELOG=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --reverse)
          fi
          
          # Escape newlines for GitHub output
          CHANGELOG="${CHANGELOG//'%'/'%25'}"
          CHANGELOG="${CHANGELOG//$'\n'/'%0A'}"
          CHANGELOG="${CHANGELOG//$'\r'/'%0D'}"
          
          echo "changelog=${CHANGELOG}" >> $GITHUB_OUTPUT

  # Build and sign installers for each platform
  build-tauri:
    name: Build ${{ matrix.platform }}
    runs-on: ${{ matrix.os }}
    needs: changelog
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-intel'
            os: 'macos-latest'
            rust_target: 'x86_64-apple-darwin'
          - platform: 'macos-arm'
            os: 'macos-latest'
            rust_target: 'aarch64-apple-darwin'
          - platform: 'linux-x86_64'
            os: 'ubuntu-20.04'
            rust_target: 'x86_64-unknown-linux-gnu'
          - platform: 'windows-x86_64'
            os: 'windows-latest'
            rust_target: 'x86_64-pc-windows-msvc'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}
          targets: ${{ matrix.rust_target }}

      - name: Install Linux dependencies
        if: matrix.platform == 'linux-x86_64'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.0-dev \
            build-essential \
            curl \
            wget \
            file \
            libssl-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            patchelf

      - name: Setup macOS code signing
        if: startsWith(matrix.os, 'macos')
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Import certificate and private key from base64 encoded secrets
          if [ -n "$APPLE_CERTIFICATE" ]; then
            echo $APPLE_CERTIFICATE | base64 --decode > certificate.p12
            security create-keychain -p "" build.keychain
            security default-keychain -s build.keychain
            security unlock-keychain -p "" build.keychain
            security import certificate.p12 -k build.keychain -P $APPLE_CERTIFICATE_PASSWORD -T /usr/bin/codesign
            security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain
            rm certificate.p12
          fi

      - name: Setup Windows code signing
        if: matrix.os == 'windows-latest'
        env:
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: |
          # Import certificate for Windows code signing
          if ("$env:WINDOWS_CERTIFICATE" -ne "") {
            [System.Convert]::FromBase64String("$env:WINDOWS_CERTIFICATE") | Set-Content -Path certificate.p12 -Encoding Byte
            Import-PfxCertificate -FilePath certificate.p12 -Password (ConvertTo-SecureString -String "$env:WINDOWS_CERTIFICATE_PASSWORD" -AsPlainText -Force) -CertStoreLocation Cert:\CurrentUser\My
            Remove-Item certificate.p12
          }

      - name: Install frontend dependencies
        working-directory: frontend
        run: npm ci

      - name: Build frontend
        working-directory: frontend
        run: npm run build

      - name: Build Tauri app
        working-directory: frontend
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          if [ "${{ matrix.platform }}" = "macos-arm" ]; then
            npm run tauri build -- --target aarch64-apple-darwin
          elif [ "${{ matrix.platform }}" = "macos-intel" ]; then
            npm run tauri build -- --target x86_64-apple-darwin
          else
            npm run tauri build
          fi
        shell: bash

      - name: Notarize macOS app
        if: startsWith(matrix.os, 'macos')
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          if [ -n "$APPLE_ID" ]; then
            # Find the .dmg file
            DMG_PATH=$(find frontend/src-tauri/target/release/bundle/dmg -name "*.dmg" | head -1)
            if [ -n "$DMG_PATH" ]; then
              echo "Notarizing $DMG_PATH"
              xcrun notarytool submit "$DMG_PATH" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" \
                --wait
              
              echo "Stapling notarization"
              xcrun stapler staple "$DMG_PATH"
            fi
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: orchflow-${{ matrix.platform }}
          path: |
            frontend/src-tauri/target/release/bundle/dmg/*.dmg
            frontend/src-tauri/target/release/bundle/appimage/*.AppImage
            frontend/src-tauri/target/release/bundle/msi/*.msi
            frontend/src-tauri/target/release/bundle/nsis/*.exe
          retention-days: 7

  # Create GitHub release and upload assets
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [changelog, build-tauri]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: Display structure of downloaded files
        run: ls -la ./artifacts

      - name: Create release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name || github.event.inputs.tag }}
          release_name: OrchFlow ${{ github.ref_name || github.event.inputs.tag }}
          body: |
            ## ðŸŽ‰ OrchFlow ${{ github.ref_name || github.event.inputs.tag }}
            
            ### What's New
            ${{ needs.changelog.outputs.changelog }}
            
            ### ðŸ“¦ Downloads
            
            **macOS:**
            - Intel: `OrchFlow_x64.dmg`
            - Apple Silicon: `OrchFlow_aarch64.dmg`
            
            **Windows:**
            - x64: `OrchFlow_x64-setup.exe` or `OrchFlow_x64.msi`
            
            **Linux:**
            - x64: `OrchFlow_x64.AppImage`
            
            ### ðŸ”„ Auto-Updates
            If you have a previous version installed, the app will automatically check for updates and prompt you to upgrade.
            
            ### ðŸ› Known Issues
            - First launch may take a few seconds to initialize
            - Some antivirus software may flag the installer (false positive)
            
            ### ðŸ“‹ System Requirements
            - **macOS:** 10.15 Catalina or later
            - **Windows:** Windows 10 version 1903 or later  
            - **Linux:** Ubuntu 18.04+ or equivalent distro
            
            ### ðŸ™ Thanks
            Special thanks to all contributors and beta testers!
          draft: false
          prerelease: ${{ contains(github.ref_name, 'beta') || contains(github.ref_name, 'alpha') || contains(github.ref_name, 'rc') }}

      - name: Upload macOS Intel DMG
        if: always()
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./artifacts/orchflow-macos-intel/OrchFlow_x64.dmg
          asset_name: OrchFlow_x64.dmg
          asset_content_type: application/octet-stream
        continue-on-error: true

      - name: Upload macOS ARM DMG
        if: always()
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./artifacts/orchflow-macos-arm/OrchFlow_aarch64.dmg
          asset_name: OrchFlow_aarch64.dmg
          asset_content_type: application/octet-stream
        continue-on-error: true

      - name: Upload Windows NSIS installer
        if: always()
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./artifacts/orchflow-windows-x86_64/OrchFlow_x64-setup.exe
          asset_name: OrchFlow_x64-setup.exe
          asset_content_type: application/octet-stream
        continue-on-error: true

      - name: Upload Windows MSI installer
        if: always()
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./artifacts/orchflow-windows-x86_64/OrchFlow_x64.msi
          asset_name: OrchFlow_x64.msi
          asset_content_type: application/octet-stream
        continue-on-error: true

      - name: Upload Linux AppImage
        if: always()
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./artifacts/orchflow-linux-x86_64/OrchFlow_x64.AppImage
          asset_name: OrchFlow_x64.AppImage
          asset_content_type: application/octet-stream
        continue-on-error: true

      - name: Generate updater signatures
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
        run: |
          # Install tauri-cli for signing
          cargo install tauri-cli --version "^1.5"
          
          # Create updater manifest
          mkdir -p release-metadata
          
          # Sign each platform's bundle for auto-updater
          for platform_dir in ./artifacts/orchflow-*; do
            platform=$(basename "$platform_dir" | sed 's/orchflow-//')
            echo "Processing platform: $platform"
            
            case "$platform" in
              "macos-intel")
                if [ -f "$platform_dir"/*.dmg ]; then
                  tauri signer sign -f "$platform_dir"/*.dmg -k "$TAURI_PRIVATE_KEY" > "release-metadata/${platform}-signature"
                fi
                ;;
              "macos-arm")
                if [ -f "$platform_dir"/*.dmg ]; then
                  tauri signer sign -f "$platform_dir"/*.dmg -k "$TAURI_PRIVATE_KEY" > "release-metadata/${platform}-signature"
                fi
                ;;
              "windows-x86_64")
                if [ -f "$platform_dir"/*.exe ]; then
                  tauri signer sign -f "$platform_dir"/*.exe -k "$TAURI_PRIVATE_KEY" > "release-metadata/${platform}-signature"
                fi
                ;;
              "linux-x86_64")
                if [ -f "$platform_dir"/*.AppImage ]; then
                  tauri signer sign -f "$platform_dir"/*.AppImage -k "$TAURI_PRIVATE_KEY" > "release-metadata/${platform}-signature"
                fi
                ;;
            esac
          done
          
          # Upload metadata
          ls -la release-metadata/

      - name: Upload release metadata
        uses: actions/upload-artifact@v4
        with:
          name: release-metadata
          path: release-metadata/
          retention-days: 90

      - name: Update latest release info
        run: |
          echo "Release created successfully!"
          echo "Tag: ${{ github.ref_name || github.event.inputs.tag }}"
          echo "Release URL: ${{ steps.create_release.outputs.html_url }}"